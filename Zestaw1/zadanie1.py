zadanie1.py
M
Typ elementu
Tekst
Rozmiar
14 KB (14 728 bajtów)
Wykorzystane miejsce
14 KB (14 728 bajtów)
Lokalizacja
zad1
Właściciel
ja
Zmodyfikowany
14:23 przeze mnie
Otwarty
14:27 przeze mnie
Utworzony
14:23 w aplikacji Google Drive Web
Dodaj opis
Przeglądający mogą pobierać
# -*- coding: utf-8 -*-
"""Zadanie1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ugqDsXwataVREzxVksCmkK-O3FNVuy9S

**Technologie**
1: numpy + 
2: matploblit
3: numpy (rand)
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np
import random
TAU = 2*np.pi

# adjacency_matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection
# adjacency list is list of lists. Length of outer list is equal to number of vertices. Inner list is empty if there is no connection to this vertex
# incidence matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection

test_adjacency_matrix =[
  [0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
  [1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
  [0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
  [0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0], 
  [1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0],
  [1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
  [0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0], 
  [0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1],
  [0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], 
  [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0] 
]

test_adjacency_list = [[1, 4, 5], [0, 2, 5], [1, 3, 4, 11], [2, 7, 8, 10], [0, 2, 6, 8], [0, 1, 6], [4, 5, 7], [3, 6, 8, 11], [3, 4, 7, 9], [8], [3], [2, 7]]

test_incidence_matrix = [
  [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
  [1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
  [0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 
  [0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], 
  [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0], 
  [0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], 
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0], 
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0], 
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1], 
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1], 
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], 
  [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
]

"""**Zadanie 1**"""

class GraphRepresentationConverter:
  @staticmethod
  def adjacency_matrix_to_adjacency_list(adjacency_matrix):
    '''
    Converts adjacency matrix to adjacency list.

    Parameters:
        adjacency_matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection

    Returns:
        adjacency list is list of lists. Length of outer list is equal to number of vertices. Inner list is empty if there is no connection to this vertex
    '''

    adjacency_list = []

    for row_index, row in enumerate(adjacency_matrix):
      adjacency_list.append([])
      for column_index, column in enumerate(row):
        if column == 1:
          adjacency_list[row_index].append(column_index)

    return adjacency_list

  @staticmethod
  def adjacency_list_to_adjacency_matrix(adjacency_list):
    '''
    Converts adjacency list to adjacency matrix.

    Parameters:
        adjacency list is list of lists. Length of outer list is equal to number of vertices. Inner list is empty if there is no connection to this vertex

    Returns:
        adjacency_matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection
    '''

    adjacency_matrix = []

    for row_index, row in enumerate(adjacency_list):
      adjacency_matrix.append([])
      for column in range(len(adjacency_list)):
        if(column in row):
          adjacency_matrix[row_index].append(1)
        else:
          adjacency_matrix[row_index].append(0)

    return adjacency_matrix

  @staticmethod
  def adjacency_list_to_incidence_matrix(adjacency_list):
    '''
    Converts adjacency list to incidence matrix.

    Parameters:
        adjacency list is list of lists. Length of outer list is equal to number of vertices. Inner list is empty if there is no connection to this vertex

    Returns:
        incidence matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection
    '''
    
    incidence_matrix = []

    #zliczenie liczby krawędzi
    number_of_edges = 0
    for row in adjacency_list:
      number_of_edges += len(row)
    number_of_edges //= 2

    #utworzenie macierzy o odpowiednim rozmiarze 
    for row in range(len(adjacency_list)):
      incidence_matrix.append([])
      for column in range(number_of_edges):
        incidence_matrix[row].append(0)

    edge = 0

    #wstawienie 1 w odpowiednich miejscach w macierzy
    for row_index, row in enumerate(adjacency_list):
      for column in range(len(row)):
        if row[column] > row_index:
          incidence_matrix[row_index][edge] = 1
          incidence_matrix[row[column]][edge] = 1
          edge+=1

    return incidence_matrix

  @staticmethod
  def incidence_matrix_to_adjacency_list(incidence_matrix):
    '''
    Converts incidence matrix to adjacency list.

    Parameters:
        incidence matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection

    Returns:
        adjacency list is list of lists. Length of outer list is equal to number of vertices. Inner list is empty if there is no connection to this vertex
    '''

    adjacency_list = []

    #stworzenie listy
    for row in range(len(incidence_matrix)):
      adjacency_list.append([])

    for column_index, column in enumerate(incidence_matrix[0]):
      prev = None
      for row_index, row in enumerate(incidence_matrix):
        if incidence_matrix[row_index][column_index] == 1:
          if prev is None:
            prev = row_index
            
          else:
            adjacency_list[row_index].append(prev)
            adjacency_list[prev].append(row_index)
        

    return adjacency_list

  @staticmethod
  def incidence_matrix_to_adjacency_matrix(incidence_matrix):
    '''
    Converts incidence matrix to adjacency matrix.

    Parameters:
        incidence matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection

    Returns:
        adjacency_matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection
    '''

    adjacency_matrix = []

    for row in range(len(incidence_matrix)):
      adjacency_matrix.append([])
      for column in range(len(incidence_matrix)):
        adjacency_matrix[row].append(0)

    for column_index, column in enumerate(incidence_matrix[0]):
      prev = None
      for row_index, row in enumerate(incidence_matrix):
        if incidence_matrix[row_index][column_index] == 1:
          if prev == None:
            prev = row_index
          else:
            adjacency_matrix[row_index][prev]= 1
            adjacency_matrix[prev][row_index]= 1

    return adjacency_matrix

  @staticmethod
  def adjacency_matrix_to_incidence_matrix(adjacency_matrix):
    '''
    Converts adjacency matrix to incidence matrix.

    Parameters:
        adjacency_matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection

    Returns:
        incidence matrix is list of lists that are equaly long and number of inner lists are equal to their length. Inner list consists of 1 and 0 representing connection
    '''

    incidence_matrix = []

    number_of_edges = 0
    for row in adjacency_matrix:
      for column in row:
        number_of_edges += column
    number_of_edges //= 2

    for row in range(len(adjacency_matrix)):
      incidence_matrix.append([])
      for column in range(number_of_edges):
        incidence_matrix[row].append(0)

    edge = 0

    for row_index, row in enumerate(adjacency_matrix):
      for column_index, column in enumerate(row):
        if row_index > column_index:
          if column == 1:
            incidence_matrix[row_index][edge] = 1
            incidence_matrix[column_index][edge] = 1
            edge+=1

    return incidence_matrix

def print_matrix(matrix):
  for row in matrix:
      print(row)

result_adjacency_list = GraphRepresentationConverter.adjacency_matrix_to_adjacency_list(test_adjacency_matrix)
print_matrix(result_adjacency_list)
if(result_adjacency_list == test_adjacency_list):
  print("Good output, test passed")

result_incidence_matrix = GraphRepresentationConverter.adjacency_list_to_incidence_matrix(test_adjacency_list)
print_matrix(result_incidence_matrix)
if(result_incidence_matrix == test_incidence_matrix):
  print("Good output, test passed")

result_adjacency_matrix = GraphRepresentationConverter.adjacency_list_to_adjacency_matrix(test_adjacency_list)
print_matrix(result_adjacency_matrix)
if(result_adjacency_matrix == test_adjacency_matrix):
  print("Good output, test passed")

result_adjacency_list = GraphRepresentationConverter.incidence_matrix_to_adjacency_list(test_incidence_matrix)
print_matrix(result_adjacency_list)
if(result_adjacency_list == test_adjacency_list):
  print("Good output, test passed")

result_adjacency_matrix = GraphRepresentationConverter.incidence_matrix_to_adjacency_matrix(test_incidence_matrix)
print_matrix(result_adjacency_matrix)
if(result_adjacency_matrix == test_adjacency_matrix):
  print("Good output, test passed")

result_incidence_matrix = GraphRepresentationConverter.adjacency_matrix_to_incidence_matrix(test_adjacency_matrix)
print_matrix(result_incidence_matrix)

# result incidence matrix has switched columns compared to test_incidence_matrix so it is no point in doing following comparison test
# if(result_incidence_matrix == test_incidence_matrix):
#   print("Good output, test passed")

"""**Zadanie 2**"""

class Vector2d:
  def __init__(self, x=0., y=0.):
    self.x = x
    self.y = y

  def rotate(self, angle):
    return Vector2d(
        self.x*np.cos(angle) - self.y*np.sin(angle), 
        self.x*np.sin(angle) + self.y*np.cos(angle)
    )
  
  def __repr__(self):
    pass
    
    return f"[{self.x}, {self.y}]"

  def to_array(self):
    return [self.x, self.y]

def generateTestMatrix(size):
  matrix = [[random.randint(0,1) for _ in range(size)] for _ in range(size)]
  for i in range(1, size):
    for j in range(i):
      matrix[i][j] = matrix[j][i]
  for i in range(size):
    matrix[i][i] = 0
  
  return matrix

class GraphPloter:
  def __init__(self, matrix, radius=10):
    self.circle = plt.Circle((0, 0), radius, fill=False)
    self.n_vertices = len(matrix)
    self.nodeRadius = 1
    self.radius = radius
    self.angle = TAU/self.n_vertices
    self.nodes = []
    self.ax = plt.gca()
    self.ax.set_xlim((-1.5*self.radius, 1.5*self.radius))
    self.ax.set_ylim((-1.5*self.radius, 1.5*self.radius))
    self.matrix = matrix

    self.add_nodes()

  def add_nodes(self):
    node = Vector2d(0, self.radius)
    for vertice in range(self.n_vertices):
      self.nodes.append(
          node
      )
      node = node.rotate(-self.angle)

  def loadMatrix(self, matrix):
    self.matrix = matrix

  def add_lines(self):
    for i in range(1, self.n_vertices):
      for j in range(i):
        if self.matrix[i][j] == 1:
          x1, y1 = self.nodes[i].to_array()
          x2, y2 = self.nodes[j].to_array()
          plt.plot([x1,x2], [y1,y2], color="b", zorder=-1)
    return self

  def writeNumbers(self, x, y, num):
    visibleNumber = num
    self.ax.text(x, y, f" {visibleNumber}", color="w") if visibleNumber < 10 else self.ax.text(x, y, f"{visibleNumber}", color="w") 

  def draw(self):
    self.add_lines()
    self.ax.add_patch(self.circle)

    for i, node in enumerate(self.nodes):

      # rusuje kółka
      self.ax.add_patch(
          plt.Circle((node.x, node.y), self.nodeRadius)
          )
      self.ax.add_patch(
          plt.Circle((node.x, node.y), self.nodeRadius, color='r', fill=False)
          )
      # rysuje liczby
      
      self.writeNumbers(node.x - self.nodeRadius/1.75, node.y - self.nodeRadius/2, i)

    plt.axis("off")
    plt.rcParams['figure.dpi'] = 200
    plt.show(self.ax)

ploter=  GraphPloter(generateTestMatrix(5)).draw()

"""**Zadanie 3**"""

class GNP:
  
  def __init__(self, n_verticies: int, probability):
    if not (0 <= probability <= 1):
      raise RuntimeError("Wrong value of p")
    if n_verticies < 1:
      raise RuntimeError("Wrong value of n")

    self.n_verticies = n_verticies
    self.probability = probability
    self.__graph = np.zeros((n_verticies, n_verticies))

    self.generate()
    self.__graph = self.__graph + self.__graph.T
  
  def __is_edge(self):
    return np.random.random() < self.probability

  @property
  def graph(self):
    """Converts numpy array to list of lists"""
    return self.__graph.astype("int32").tolist()

  def get_raw(self):
    """"Returns numpy array"""
    return self.__graph
  
  def generate(self):
    for i in range(self.n_verticies):
      for j in range(i, self.n_verticies):
        if self.__is_edge():
          self.__graph[i,j] = 1

GNP(10, 0.5).get_raw().sum()

gnp = GNP(10, 0.5)
gnp.graph

GraphPloter(GNP(10, 0.5).graph).draw()

class GNL:
  
  def __init__(self, n_verticies: int, n_edges: int):
    if n_verticies < 1:
      raise RuntimeError("Wrong number of verticies")
    
    if n_edges < 1:
      raise RuntimeError("Wrong number of edges")

    self.n_verticies = n_verticies
    self.n_edges = n_edges
    self.__graph = np.zeros((n_verticies, n_verticies))

    self.generate()
  
  @property
  def graph(self):
    return self.__graph.astype("int32").tolist()

  def get_raw(self):
    return self.__graph
  
  def generate(self):
    counter = 0
    while counter < self.n_edges:
       #losuj
      i = np.random.randint(1, self.n_verticies)
      j = np.random.randint(1, self.n_verticies)
    
      if self.__graph[i,j] == 1 or i == j:
        continue
      else:
        self.__graph[i,j] = 1
        self.__graph[j,i] = 1
        counter += 1

GraphPloter(GNL(10, 5).graph).draw()

"""**Testowanie**"""

GraphPloter(GNP(5, 0.33).graph).draw()

GraphPloter(GNL(10, 5).graph).draw()

graph = GNL(10, 5).graph

graph

GraphRepresentationConverter.adjacency_matrix_to_adjacency_list(graph)

"""***Testowanie zadanie 1***"""

GraphPloter(test_adjacency_matrix).draw()
